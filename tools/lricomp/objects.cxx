/***************************************************************************
 *
 * (C) Copyright 1998 by NADS & Simulation Center, The University of Iowa,
 * and The University of Iowa.  All rights reserved.
 *
 *	$Id: objects.cxx,v 1.1 2005/06/10 17:43:35 yhe Exp $
 *
 * Author(s):   Yiannis Papelis
 * Date:        October, 1998
 * 
 * Generates the object related data structures
 *
 */
#ifdef _WIN32
#pragma warning( disable : 4786 )  
#include <ostream>
#include <iostream>
#elif __sgi
#include <typeinfo>
#include <iostream.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <sol2.h>
#include <transmat.h>
#include "parser.h"
#include "dbgdump.h"
#include "err.h"

/* this function "borrowed" from the libsrc directory */
cvEObjType cvString2ObjType(const char *);

static CSol  s_Sol;

/*
 * Converts a sol name to a sol id.  Will eventually move
 * to a different file that is automatically generated by sol.
 * For now, just return a 'dummy' sol id.
 */
static int SolName2SolId(const char *pType)
{
	if ( pType == NULL ) return -1;
	return 1;
}

/*
 * This function produces the object attribute pool and the
 * the object pool.  
 *
 * The object pool is larger than the number of objects in the
 * lri file as it contains space for additional objects that can
 * be created dynamically.  
 * The pool is divided in two parts, the space for the dynamic
 * objects and the space for the static objects.  Dynamic objects
 * reside in the first N entries of the pool, where N is a runtime
 * constant, and the remaining entries reflect static objects
 * which come from the LRI file (along with a bit more space for
 * dynamically created static objects).
 *
 * Object attributes are stored in a similar fashion, however,
 * each static object can have more than one attribute so the
 * total number of attributes can be more than the number of
 * objects.  The mapping of dynamic object slots to attribute
 * slots is straightforward since dynamic objects are stored
 * first, and dynamic objects can't have multiple attributes.
 */
void
GenerateObjects(
	const TObject    *pObjs, 
	int              objCount,
	cvTObj           **pObjPool,
	int              *pObjPoolSize)
{
	extern      int  gDebugDump;
	extern      int  sizeOfCharPool;
	void        SetCharPool(const char *);
	int         i, j;
	cvTObj      obj = { 0 };
	int         duplicate;
	// nDupEntries;
	int         objActualCount = 0;
//	int         attrCount = 0;

	if (!s_Sol.Init()) {
		cout << "SOL Error: " << s_Sol.GetLastError() << endl;
	}

	/* Alloc memory for object & attr pool; leave enough size of
	 * dynamic objects and few additional static objects.
	 * Note that the objCount hold the number of object entries
	 * in the lri file and the actual number of objects could
	 * be smaller if multiple entries provide different options
	 * for the same object.  We keep track of the actual number
	 * of objects in objActualCount;
	 */
	*pObjPoolSize = cNUM_DYN_OBJS + objCount + cEXTRA_OBJ_SLOTS;
	*pObjPool = (cvTObj *)malloc( *pObjPoolSize * sizeof(cvTObj));

//	*pObjAttrPoolSize = *pObjPoolSize;
//printf("## bytes = %d\n", *pObjAttrPoolSize * sizeof(cvTObjAttr) );
//	*pObjAttrPool = (cvTObjAttr *)malloc(*pObjAttrPoolSize * sizeof(cvTObjAttr));
	
//	attrCount = cNUM_DYN_OBJS;
	for (i=0; i<objCount; i++) {
		/* if this object is already defined and this entry
		 * simply provides new attributes, we treat it specially
		 */
		duplicate = 0;
		for (j=0; j<i; j++) {
			if ( !strcmp(pObjs[i].name, pObjs[j].name) ) {
				duplicate = 1;
			}
		}
		if ( duplicate ) {
			lrierr(eSEMANTICS_ERROR, "duplicate object '%s'.", pObjs[i].name);
		}

#if 0
		/* if this object has multiple options, we verify that
		 * all object definitions are consistent and 
		 * count how many attribute slots we need  
		 */
		duplicate   = 0;
		nDupEntries = 0;
		for (j=i+1; j<objCount; j++) {
			if ( !strcmp(pObjs[i].name, pObjs[j].name) ) {
				duplicate = 1;
				nDupEntries++;
				cout << "Error:  Object '" << pObjs[i].name << "' is duplicated." << endl;
				exit(-1);
			}
		}
#endif

		/* id is the slot this object is stored at */
		obj.myId = cNUM_DYN_OBJS + objActualCount;

		/* type comes from lookup table */
		obj.type = cvString2ObjType(pObjs[i].type);
		if ( obj.type == eCV_INVALID ) {
			lrierr(eBAD_OBJECT_TYPE, "Type = '%s' for object '%s'.",
					pObjs[i].type, pObjs[i].name);
		}

		/* name is stored in char pool */
		strncpy(obj.name, pObjs[i].name, cOBJ_NAME_LEN-1);

		/* phase is initialized to Alive */
		obj.phase      = eALIVE;

		// The TObject struct has the following:
		//	float  x, y, z, yaw;
		//	int    plant;
		//

		/* define position/orientation */
		obj.stateBufA.state.anyState.position.x = pObjs[i].x;
		obj.stateBufA.state.anyState.position.y = pObjs[i].y;
		obj.stateBufA.state.anyState.position.z = pObjs[i].z;
		obj.stateBufA.state.anyState.tangent.i  = cos(pObjs[i].yaw);
		obj.stateBufA.state.anyState.tangent.j  = sin(pObjs[i].yaw);
		obj.stateBufA.state.anyState.tangent.k  = 0.0;
		obj.stateBufA.state.anyState.lateral.i  = sin(pObjs[i].yaw);
		obj.stateBufA.state.anyState.lateral.j  = 0 - cos(pObjs[i].yaw);
		obj.stateBufA.state.anyState.lateral.k  = 0.0;

		/* TODO:
		 * Here, knowing the orientation of an object, we have
		 * to go into any orientation-dependant state variables
		 * and apply the proper rotation.  For example, a
		 * cultural feature whose outline is defined by a
		 * polygon would have its vertices rotated about its
		 * origin.
		 * The code has to be type-specific.
		 */

		/* one option per duplicate entry, first entry is current */
		obj.activeOption = 0;

		const CSolObj  *pSolObj;

		pSolObj = s_Sol.GetObj(pObjs[i].sol);
		if ( pSolObj == NULL ) {
			lrierr(eBAD_SOL_NAME, "SolId = '%s' for object '%s'.",
					pObjs[i].sol, pObjs[i].name);
			exit(-1);
		}
//		attr.solId  = ToBeAdded by Yiannis
		// Yiannis:  I added this line, and it seems ok to me
		//	Jillian
		obj.attr.solId  = pSolObj->GetId();
		obj.attr.hcsmId = -1;
		obj.attr.xSize  = pSolObj->GetWidth();
		obj.attr.ySize  = pSolObj->GetLength();
		obj.attr.zSize  = pSolObj->GetHeight();
		obj.attr.cigi   = pObjs[i].cigi;

// set up the bounding box of the object
		vector<CPoint2D>	pts;
		CPoint2D			pt;

		const CSolObjTerrain* pTerrainObj = dynamic_cast<const CSolObjTerrain*>( pSolObj);
		if (pTerrainObj) {
			CBoundingBox box = pTerrainObj->GetMap().GetBoundingBox();
			pt.m_x = box.GetMinX();
			pt.m_y = box.GetMinY();
			pts.push_back(pt);
			pt.m_x = box.GetMinX();
			pt.m_y = box.GetMaxY();
			pts.push_back(pt);
			pt.m_x = box.GetMaxX();
			pt.m_y = box.GetMaxY();
			pts.push_back(pt);
			pt.m_x = box.GetMaxX();
			pt.m_y = box.GetMinY();
			pts.push_back(pt);
		} else {
			pt.m_x = 0 - obj.attr.xSize/2;
			pt.m_y = 0 - obj.attr.ySize/2;
			pts.push_back(pt);
			pt.m_x = 0 - obj.attr.xSize/2;
			pt.m_y = 0 + obj.attr.ySize/2;
			pts.push_back(pt);
			pt.m_x = 0 + obj.attr.xSize/2;
			pt.m_y = 0 + obj.attr.ySize/2;
			pts.push_back(pt);
			pt.m_x = 0 + obj.attr.xSize/2;
			pt.m_y = 0 - obj.attr.ySize/2;
			pts.push_back(pt);
		}

		CTransMat rotMatrix;
		rotMatrix.RotZ(pObjs[i].yaw);
		vector<CPoint2D>::iterator tempIdx;
		for (tempIdx = pts.begin(); tempIdx != pts.end(); tempIdx++){
			*tempIdx = rotMatrix.Apply(*tempIdx);
			tempIdx->m_x += pObjs[i].x;
			tempIdx->m_y += pObjs[i].y;
#if 0
	printf("\n--------- obj %d  x = %f y = %f", i, tempIdx->m_x,tempIdx->m_y);
#endif
		}
		CBoundingBox bb(pts);
		obj.stateBufA.state.anyState.boundBox[0].x = float(bb.GetMinX());
		obj.stateBufA.state.anyState.boundBox[0].y = float(bb.GetMinY());
		obj.stateBufA.state.anyState.boundBox[1].x = float(bb.GetMaxX());
		obj.stateBufA.state.anyState.boundBox[1].y = float(bb.GetMaxY());

		// Set stateBufB to stateBufA
		obj.stateBufB = obj.stateBufA;

#if 0
		CPoint2D pt[4];

		pt[0].m_x = 0 - obj.attr.xSize/2;
		pt[0].m_y = 0 - obj.attr.ySize/2;
		pt[1].m_x = 0 - obj.attr.xSize/2;
		pt[1].m_y = 0 + obj.attr.ySize/2;
		pt[2].m_x = 0 + obj.attr.xSize/2;
		pt[2].m_y = 0 + obj.attr.ySize/2;
		pt[3].m_x = 0 + obj.attr.xSize/2;
		pt[3].m_y = 0 - obj.attr.ySize/2;

		CTransMat rotMatrix;
		rotMatrix.RotZ(pObjs[i].yaw);
		int tempIdx;
		for (tempIdx = 0; tempIdx < 4; tempIdx++){
			pt[tempIdx] = rotMatrix.Apply(pt[tempIdx]);
			pt[tempIdx].m_x += pObjs[i].x;
			pt[tempIdx].m_y += pObjs[i].y;
		}
		CBoundingBox bb(pt, 4);
		obj.stateBufA.state.anyState.boundBox[0].x = bb.GetMinX();
		obj.stateBufA.state.anyState.boundBox[0].y = bb.GetMinY();
		obj.stateBufA.state.anyState.boundBox[1].x = bb.GetMaxX();
		obj.stateBufA.state.anyState.boundBox[1].y = bb.GetMaxY();

#endif

// end of setup of boundingbox
#if 0
	fprintf(stdout, "\n obj %d  length = %f width = %f height = %f", 
		i, attr.xSize, attr.ySize, attr.zSize);
	fprintf(stdout, "\n\t min coordinate x = %f  y = %f", 
		obj.stateBufA.state.anyState.boundBox[0].x, 
		obj.stateBufA.state.anyState.boundBox[0].y);
	fprintf(stdout, "\n\t Max coordinate x = %f  y = %f", 
		obj.stateBufA.state.anyState.boundBox[1].x, 
		obj.stateBufA.state.anyState.boundBox[1].y);
#endif


//		(*pObjAttrPool)[attrCount] = obj.attr;
//		attrCount++;
#if 0
		for (j=i+1; j<objCount; j++) {
			if ( !strcmp(pObjs[i].name, pObjs[j].name) ) {
				//attr.solId  = SolName2SolId(pObjs[j].sol);
				// Yiannis:  I added these lines and commented out
		        // the line above Lijen  
				pSolObj = s_Sol.GetObj(pObjs[j].sol);
				if ( pSolObj == NULL ) {
					lrierr(eBAD_SOL_NAME, "SolId = '%s' for object '%s'.",
					pObjs[j].sol, pObjs[j].name);
					exit(-1);
				}
				obj.attr.solId = pSolObj->GetId();
				obj.attr.hcsmId = -1;
				obj.attr.xSize  = pSolObj->GetWidth();
				obj.attr.ySize  = pSolObj->GetLength();
				obj.attr.zSize  = pSolObj->GetHeight();

				(*pObjAttrPool)[attrCount++] = obj.attr;
			}
		}
#endif

		(*pObjPool)[cNUM_DYN_OBJS + objActualCount] = obj;
		objActualCount++;
	}


	*pObjPoolSize     = objActualCount + cNUM_DYN_OBJS;
//	*pObjAttrPoolSize = attrCount;

	if ( gDebugDump ) {
		DumpObjPool(*pObjPool, *pObjPoolSize);
//		DumpObjAttrPool(*pObjAttrPool, *pObjAttrPoolSize);
	}
}
