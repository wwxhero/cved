// Version: 		$Id: testQuadTree.cxx,v 1.3 2000/04/07 18:34:39 schikore Exp $
//

#include <list.h>
#include <vector.h>
#include <set.h>

#include "QuadTree.h"

typedef QuadTree::Item TItem;
typedef vector<QuadTree::Item> TItemVector;
typedef set<TItem> TItemSet;

ostream & operator<<(ostream &str, const TItem &it)
{
	str << "(" << it.x1 << " ," << it.y1 << ") - ("
			<< it.x2 << " ," << it.y2 << ")";
	return str;
}

ostream & operator<<(ostream &str, const set<int> &items)
{
	set<int>::const_iterator  it;

	for (it = items.begin(); it != items.end(); it++) {
		str << *it << " ";
	}
	return str;
}

/////////////////////////////////////////////////////////////////////////////
//
// Remarks:
// This function generates a set of rectangles based on the input
// parameters.
//
// Arguments:
//  count - how many rectangles to create
//  minSize - min size of rectangles (in either direction)
//  maxSize - max size of rectangles (in either direction);
//  area - how big of an area the rectangles should be spread
// 
void GenerateRects(
	int count, 
	float minSize, 
	float maxSize, 
	float area,
	TItemVector &output)
{
	int    rect;
	TItem  item;
	int    id=0;

	output.clear();
	for (rect=0; rect<count; rect++) {
		float origin, xsize, ysize;

		origin = (1.0 * rand() / RAND_MAX) * area;
		xsize  = minSize + (1.0 * rand() / RAND_MAX) * (maxSize - minSize);
		ysize  = minSize + (1.0 * rand() / RAND_MAX) * (maxSize - minSize);
		item.id = id++;
		item.x1 = origin;
		item.y1 = origin;
		item.x2 = origin + xsize;
		item.y2 = origin + ysize;
		
		output.push_back(item);
	}
}


//////////////////////////////////////////////////////////////////////////
//
// Remarks:
// This function generates a list of queries with the specified
// parameters.  Queries are represented as a vector of
// items whose rectangle represents the area to be searched.
// The function generates query rectangles by scanning the maximum
// area specified the specified x and y step.  The size of each
// rectangle is copied from the array sizes.  One query 
// rectangle will be generated by combining an origin with
// the size of each rectangle in sizes.
//
// Arguments:
// area  - the area to cover 
// xStep - increment step on x direction
// yStep - increment step on y direction
// sizes - a list of TItems to be used for deriving size of query
// output - where to store the final rectangles
//
void
GenerateQueries(
	const TItem 			&area,
	float 					xStep,
	float 					yStep,
	const TItemVector       &sizes,
	TItemVector 			&output)
{
	float  xorig, yorig;
	TItem  item;

	output.clear();
	for ( xorig=area.x1; xorig <= area.x2; xorig += xStep ) {
		for ( yorig=area.y1; yorig <= area.y2; yorig += yStep ) {
			TItemVector::const_iterator pS;

			for ( pS=sizes.begin(); pS != sizes.end(); pS++) {
				item.x1 = xorig;
				item.y1 = yorig;
				item.x2 = xorig + pS->x2 - pS->x1;
				item.y2 = yorig + pS->y2 - pS->y1;

				output.push_back(item);
			}
		}
	}
}
	

///////////////////////////////////////////////////////////////////////////
//
// This function performs a search on the provided quatree with
// the provided rectangles as inputs.
// The function does not store the results as it is simply used
// to measure execution speed.
//
// Arguments:
//  qtree - the quadtree to interrogate
//  queries - the list of queries to apply to the quadtree
//  result - a vector of sets of integers, each set is the
//         answer to the corresponding query
//
void SearchTiming(
	QuadTree					&qtree,
	const TItemVector				&queries)
{
	TItemVector::const_iterator   pI;
	vector<int>  result;

	for ( pI=queries.begin(); pI != queries.end(); pI++ ) {
		qtree.SearchRectangle(pI->x1, pI->y1, pI->x2, pI->y2, result);
	}
}


/////////////////////////////////////////////////////////////////////////
// 
// This function inserts the provided list of rectangles to the
// provided quadtree
//
void
InsertRectangles(
	QuadTree 						&qtree,
	const TItemVector				&rects)
{
	TItemVector::const_iterator  pI;

	try {
		for ( pI=rects.begin(); pI != rects.end(); pI++ ) {
			qtree.Insert(*pI);
		}
	}
	catch ( const char *pEr ) {
		cout << "Exception caught while inserting " << *pI << endl;
	}

}


/////////////////////////////////////////////////////////////////////////
//
// This function performs a search on the list of provided 
// rectangles.  It performs a lookup functionally equivalent to the
// quadtree search function but it uses a brute force approach.
//
int
BruteForceSearch(
	const TItemVector				&rectList,
	const TItem						&query,
	vector<int>						&result
)
{
	TItemVector::const_iterator    pI;

	result.clear();
	for ( pI=rectList.begin(); pI != rectList.end(); pI++ ) {
		if ( QuadTree::AlignedRectInter(*pI, query) ) 
			result.push_back(pI->id);
	}
	return result.size();
}


void Test1(void)
{
	float       area;			// the area to spread objects in
	TItem       sz;				// scratch variable for sizes
	int         nRects;			// how many rectangles in the search
	TItemVector sizes;			// the sizes for interrogations
	TItemVector rects;			// the rectangles
	TItemVector queries;		// the queries
	float       xStep, yStep;	// traversal step for queries
	QuadTree    qtree;			// the quadtree class to test


	// define values
	nRects      = 1000;
	area        = 1500.0;
	xStep       = 20.0;
	yStep       = 20.0;

	TItem       areaRect;		// the area to cover with items
	areaRect.x1 = areaRect.y1 = 0.0;
	areaRect.x2 = areaRect.y2 = area;

	cout << "+++ Test 1" << endl;
	sizes.clear();

	sz.x1 = sz.y1 = 0.0;
	sz.x2 = 3.0;
	sz.y2 = 1.0;
	sizes.push_back(sz);
	sz.x1 = sz.y1 = 0.0;
	sz.x2 = 4.0;
	sz.y2 = 10.0;
	sizes.push_back(sz);

	cout << "Generating data ..." << endl;
	GenerateRects(nRects, 3.0, 80.0, area, rects);
	GenerateQueries(areaRect, xStep, yStep, sizes, queries);

	cout << "Performing insertions ..." << endl;
	InsertRectangles(qtree, rects);

	cout << "Performing interrogations ..." << endl;
	TItemVector::const_iterator pI;
	int count = 0;
	for ( pI=queries.begin(); pI != queries.end(); pI++ ) {
		int       n1, n2;
		vector<int>  res1, res2;

		n1 = BruteForceSearch(rects, *pI, res1);
		n2 = qtree.SearchRectangle(pI->x1, pI->y1, pI->x2, pI->y2, res2);

		if ( n1 != n2 || res1 != res2 ) {
			if ( n1 != n2 ) {
				cout << "** Diff size results.\n"
					<< "Interrogation rectangle: " << *pI << endl
					<< "Brute force returned " << n1 << " objs, quadtree "
					<< n2 << " objs" << endl;
			}
			else {
				cout << "*** Different results.\n"
					<< "Interrogation rectangle: " << *pI
					<< "Brute force returned: " << res1 << endl
					<< "Quadtree returned: " << res2 << endl;
			}

		}
		count++;
		if ( count % 30 == 0 )
			printf("%d\n", count);
	}
	cout << "Done" << endl;
}


int main(int argc, char **argv)
{
	srand(0);

	Test1();
}
